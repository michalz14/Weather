#!/usr/bin/env ruby
# -*- coding: utf-8 -*-

require_relative 'codegen'

class ProtocolGenerator

  def generate_namespace_protocol(main_name, merged_data, struct_registry, output_dir: nil)
    namespace = "#{main_name}Namespace"
    protocol_name = "#{main_name}Protocol"

    props = build_protocol_properties(merged_data, namespace)
    protocol_code = render_protocol(protocol_name, props)
    namespace_code = render_namespace(namespace, struct_registry)

    base = (output_dir && !output_dir.to_s.strip.empty?) ? output_dir : nil
    Codegen.write_file(path_for(base, "#{namespace}.swift"), namespace_code)
    Codegen.write_file(path_for(base, "#{protocol_name}.swift"), protocol_code)
  end

  private

  def build_protocol_properties(data, namespace)
    data.map do |k, v|
      { name: Codegen.property_name(k), type: Codegen.swift_type(v, k, prefix: namespace) }
    end
  end

  def render_protocol(name, props)
    interface = props.map { |p| "    public var #{p[:name]}: #{p[:type]} { get }" }.join("\n")
    defaults  = props.map { |p| "    var #{p[:name]}: #{p[:type]} { #{Codegen.default_for_type(p[:type])} }" }.join("\n")
    <<~SWIFT
      import Foundation

      public protocol #{name} {
      #{interface}
      }

      public extension #{name} {
      #{defaults}
      }
    SWIFT
  end

  def render_namespace(namespace, structs)
    # Zbuduj graf zależności parent -> children (po typach własnych struktur)
    children_map = Hash.new { |h, k| h[k] = [] }
    referenced = Hash.new(false)

    structs.each do |struct_name, props|
      props.each do |k, v|
        t = Codegen.swift_type(v, k, prefix: namespace)
        # typ własnej struktury: bez prefixu w bazowym registry (np. FeatureFlags)
        if t.start_with?("#{namespace}.")
          child_name = t.split('.').last.gsub(/\[|\]|\?/, '')
          if structs.key?(child_name)
            children_map[struct_name] << child_name unless children_map[struct_name].include?(child_name)
            referenced[child_name] = true
          end
        elsif structs.key?(t)
          # przypadek gdy swift_type zwrócił nazwę bez prefixu (brak prefix param)
          children_map[struct_name] << t unless children_map[struct_name].include?(t)
          referenced[t] = true
        end
      end
    end

    # Rooty to takie które nie są childem żadnego innego
    roots = structs.keys.reject { |name| referenced[name] }

    rendered = roots.map do |root|
      render_struct_with_children(root, structs, children_map, namespace, indent: 1)
    end.join("\n\n")

    <<~SWIFT
      import Foundation

      public enum #{namespace} {
      #{rendered}
      }
    SWIFT
  end

  def render_struct_with_children(name, structs, children_map, namespace, indent: 1)
    props = structs[name] || {}
    # Najpierw zagnieżdżone dzieci
    nested_blocks = (children_map[name] || []).map do |child|
      render_struct_with_children(child, structs, children_map, namespace, indent: indent + 1)
    end.join("\n\n")

    header = Codegen.indent("public struct #{name} {", indent)
    body_parts = []
    body_parts << nested_blocks unless nested_blocks.empty?

    # Własne właściwości
    prop_lines = props.map do |k, v|
      pname = Codegen.property_name(k)
      ptype = Codegen.swift_type(v, k, prefix: namespace)
      Codegen.indent("public let #{pname}: #{ptype}", indent + 1)
    end
    body_parts << prop_lines.join("\n") unless prop_lines.empty?

    # Konstruktor
    ctor_params = []
    assigns = []
    props.each do |k, v|
      pname = Codegen.property_name(k)
      ptype = Codegen.swift_type(v, k, prefix: namespace)
      ctor_params << "#{pname}: #{ptype} = #{Codegen.default_for_type(ptype)}"
      assigns << Codegen.indent("self.#{pname} = #{pname}", indent + 2)
    end
    ctor = if props.empty?
      Codegen.indent("public init() { }", indent + 1)
    else
      [
        Codegen.indent("public init(#{ctor_params.join(', ')}) {", indent + 1),
        assigns.join("\n"),
        Codegen.indent('}', indent + 1)
      ].join("\n")
    end
    body_parts << ctor

    [
      header,
      body_parts.reject(&:empty?).join("\n\n"),
      Codegen.indent('}', indent)
    ].join("\n")
  end

  def path_for(dir, file)
    return file unless dir
    File.join(dir, file)
  end

end
