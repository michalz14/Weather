1.
module Codegen
  # ===== Rekurencyjne generowanie zagnieżdżonych struktur =====
  def struct_block_with_children(name, structs, children_map, access: '', prefix: nil, defaults: true, constructor: true, indent: 1)
    props = structs[name] || {}
    # Najpierw zagnieżdżone dzieci
    nested_blocks = (children_map[name] || []).map do |child|
      struct_block_with_children(child, structs, children_map, access: access, prefix: prefix, defaults: defaults, constructor: constructor, indent: indent + 1)
    end.join("\n\n")

    opts = {
      name: name,
      properties: props,
      access: access,
      prefix: prefix,
      defaults: defaults,
      constructor: constructor,
      indent: indent
    }
    header = indent("#{access}struct #{name} {", indent)
    body_parts = []
    body_parts << nested_blocks unless nested_blocks.empty?
    body_parts << build_property_lines(normalize_struct_opts(opts)) unless props.empty?
    body_parts << build_constructor(normalize_struct_opts(opts)) if constructor
    [
      header,
      body_parts.reject(&:empty?).join("\n\n"),
      indent('}', indent)
    ].join("\n")
  end
  module_function :struct_block_with_children
  INDENT = "\t".freeze

  module_function

  # ===== Formatting =====
  def indent(text, level = 1)
    pad = INDENT * level
    text.lines.map { |l| l.strip.empty? ? l : pad + l }.join.rstrip
  end

  # ===== Naming =====
  def struct_name(key)
    return "" if key.to_s.empty?
    key.to_s.sub(/^./, &:upcase)
  end

  def array_struct_name(key)
    struct_name(key.to_s.chomp('s').chomp('Types'))
  end

  def property_name(key)
    base = key.to_s.gsub(/\s+/, '_').gsub(/[^a-zA-Z0-9_]/, '')
    return base if base.empty?
    return normalize_snake(base) if base.include?('_')
    base.sub(/^./, &:downcase)
  end

  def normalize_snake(str)
    parts = str.split('_').reject(&:empty?)
    return '' if parts.empty?
    first = parts.shift.downcase
    first + parts.map { |p| p.sub(/^./, &:upcase) }.join
  end
  private_class_method :normalize_snake

  def main_struct_name(filename)
    File.basename(filename, '.plist')
  end

  # ===== Type inference =====
  def swift_type(value, key = nil, prefix: nil)
    case value
    when String  then 'String'
    when Integer then 'Int'
    when Float   then 'Double'
    when TrueClass, FalseClass then 'Bool'
    when Time, Date then 'Date'
    when NilClass then 'String?'
    when Array   then array_type(value, key, prefix: prefix)
    when OptionalValue
      base = swift_type(value.value, key, prefix: prefix)
      "#{base}?"
    when Hash
      name = struct_name(key)
      prefix ? "#{prefix}.#{name}" : name
    else
      'String'
    end
  end

  def array_type(arr, key, prefix: nil)
    return '[Any]' if arr.empty? || heterogeneous?(arr)
    first = arr.first
    if first.is_a?(Hash)
      name = array_struct_name(key)
      full = prefix ? "#{prefix}.#{name}" : name
      "[#{full}]"
    else
      "[#{swift_type(first, nil, prefix: prefix)}]"
    end
  end

  def heterogeneous?(arr)
    return false if arr.size <= 1
    cls = arr.first.class
    !arr.all? { |e| e.class == cls }
  end

  # ===== Default values =====
  def default_for_type(type)
    return 'nil' if type.nil? || type.strip.empty? || type.end_with?('?')
    return '[]' if type.start_with?('[')
    {
      'String' => '""',
      'Int'    => '0',
      'Double' => '0.0',
      'Bool'   => 'false',
      'Date'   => 'Date()'
    }[type] || (type.match?(/^[A-Z]\w*(\.[A-Za-z0-9_]+)*$/) ? ".init()" : 'nil')
  end

  # ===== Literal generation =====
  def literal(value, key = nil, prefix: nil)
    case value
    when String  then %("#{escape(value)}")
    when Integer, Float then value.to_s
    when TrueClass, FalseClass then value.to_s
    when Time, Date then 'Date()'
    when NilClass then 'nil'
    when OptionalValue then value.value.nil? ? 'nil' : literal(value.value, key, prefix: prefix)
    when Array then array_literal(value, key, prefix: prefix)
    when Hash  then struct_literal(value, key, prefix: prefix)
    else %("#{escape(value.to_s)}")
    end
  end

  def escape(str) = str.to_s.gsub('"', '\\"')

  def array_literal(arr, key, prefix: nil)
    return '[]' if arr.empty?
    if heterogeneous?(arr)
      multiline(arr.map { |el| heterogeneous_element_literal(el, key, prefix: prefix) })
    elsif arr.first.is_a?(Hash)
      name = array_struct_name(key)
      multiline(arr.map { |el| struct_instance(el, name, prefix: prefix) })
    else
      "[#{arr.map { |el| literal(el, nil, prefix: prefix) }.join(', ')}]"
    end
  end

  def heterogeneous_element_literal(el, key, prefix: nil)
    el.is_a?(Hash) ? struct_instance(el, array_struct_name(key), prefix: prefix) : literal(el, key, prefix: prefix)
  end

  def struct_literal(hash, key, prefix: nil)
    struct_instance(hash, struct_name(key), prefix: prefix)
  end

  def struct_instance(hash, name, prefix: nil)
    args = hash.map { |k, v| "#{property_name(k)}: #{literal(v, k, prefix: prefix)}" }.join(', ')
    qualified = prefix ? "#{prefix}.#{name}" : name
    "#{qualified}(#{args})"
  end

  def multiline(items)
    return '[]' if items.empty?
    inner = items.map { |c| INDENT + c }.join(",\n")
    "[\n#{inner}\n]"
  end

  # ===== Struct generation =====
  StructOptions = Struct.new(:name, :properties, :access, :prefix, :defaults, :constructor, :indent)

  def struct_block(opts)
    opts = normalize_struct_opts(opts)
    prop_lines = build_property_lines(opts)
    ctor = build_constructor(opts) if opts.constructor
    body = [prop_lines, ctor].compact.join("\n")
    [
      indent("#{opts.access}struct #{opts.name} {", opts.indent),
      body,
      indent('}', opts.indent)
    ].reject(&:empty?).join("\n")
  end

  def normalize_struct_opts(opts)
    case opts
    when StructOptions then opts
    when Hash
      StructOptions.new(
        opts[:name],
        opts[:properties] || {},
        opts[:access] || '',
        opts[:prefix],
        opts.fetch(:defaults, true),
        opts.fetch(:constructor, true),
        opts[:indent].to_i
      )
    else
      raise ArgumentError, "Unsupported opts: #{opts.inspect}"
    end
  end
  private_class_method :normalize_struct_opts

  def build_property_lines(opts)
    return '' if opts.properties.empty?
    opts.properties.map do |k, v|
      pname = property_name(k)
      ptype = swift_type(v, k, prefix: opts.prefix)
      line = "#{opts.access}let #{pname}: #{ptype}"
      line += " = #{literal(v, k, prefix: opts.prefix)}" if opts.defaults
      indent(line, opts.indent + 1)
    end.join("\n")
  end
  private_class_method :build_property_lines

  def build_constructor(opts)
    return indent("#{opts.access}init() { }", opts.indent + 1) if opts.properties.empty?
    params = []
    assigns = []
    opts.properties.each do |k, v|
      pname = property_name(k)
      ptype = swift_type(v, k, prefix: opts.prefix)
      params << "#{pname}: #{ptype} = #{default_for_type(ptype)}"
      assigns << indent("self.#{pname} = #{pname}", opts.indent + 2)
    end
    [
      indent("#{opts.access}init(#{params.join(', ')}) {", opts.indent + 1),
      assigns.join("\n"),
      indent('}', opts.indent + 1)
    ].join("\n")
  end
  private_class_method :build_constructor

  # ===== File IO =====
  def write_file(path, content)
    require 'fileutils'
    dir = File.dirname(path)
    FileUtils.mkdir_p(dir) unless dir == '.'
    File.write(path, content)
  end
end


2.
#!/usr/bin/env ruby
# -*- coding: utf-8 -*-

require 'plist'
require_relative 'codegen'
require_relative 'plist_to_swift'
require_relative 'protocol_generator'

class ConfigGenerator
  CONFIG_FILES = [
    'Configurations/ConfigurationPREM.plist',
    'Configurations/ConfigurationUREV.plist'
  ].freeze

  def initialize(main_name)
    @main_name = main_name
    @namespace_output_dir = 'Constants'
    @structs_output_dir   = 'Outputs'
  end

  def generate_all
    # Krok 1: Pobierz dane z pierwszego pliku plist
    first_plist = CONFIG_FILES.find { |plist_file| File.exist?(plist_file) }
    unless first_plist
      puts "Brak plików plist do wygenerowania!"
      return
    end
    data = Plist.parse_xml(first_plist)
    analyzer = PlistAnalyzer.new(data)
    struct_registry = analyzer.analyze

    # Krok 2: Wygeneruj protokół oraz enum Namespace z typami zagnieżdżonymi
    generate_namespace_protocol(data, struct_registry)

    # Krok 3: Generuj pojedyncze pliki struct ze wskazaniem na Namespace
    generate_swift_structs

    puts "✅ Wszystkie konfiguracje zostały wygenerowane!"
  end

  private

  def generate_namespace_protocol(data, struct_registry)
    protocol_gen = ProtocolGenerator.new
    protocol_gen.generate_namespace_protocol(@main_name, data, struct_registry, output_dir: @namespace_output_dir)
  end



  def generate_swift_structs
    CONFIG_FILES.each do |plist_file|
      if File.exist?(plist_file)
        PlistToSwift.new(
          plist_file,
          prefix: "#{@main_name}Namespace",
          skip_nested: true,
          output_dir: @structs_output_dir
        ).generate
      else
        # file missing - skip silently
      end
    end
  end
end

# Uruchomienie jeśli skrypt jest wywołany bezpośrednio
if __FILE__ == $0
  main_name = ARGV[0]
  if main_name.nil? || main_name.strip.empty?
    exit 1
  end
  generator = ConfigGenerator.new(main_name)
  generator.generate_all
end


3.
#!/usr/bin/env ruby
# -*- coding: utf-8 -*-

require 'plist'
require 'optparse'
require 'fileutils'
require_relative 'codegen'

# Klasa reprezentująca opcjonalną wartość w strukturze
class OptionalValue
  attr_reader :value
  
  def initialize(value)
    @value = value
  end
end

# Klasa odpowiedzialna za generowanie kodu Swift
class SwiftFileGenerator
  def initialize(structs:, prefix:, skip_nested: true, with_defaults: true)
    @structs = structs
    @prefix = prefix
    @skip_nested = skip_nested
    @with_defaults = with_defaults
  end

  def render_top_struct(name, data)
    nested = @skip_nested ? '' : nested_blocks
    props  = data.map { |k, v| property_line(k, v) }.join("\n")
    <<~SWIFT
      import Foundation

      struct #{name} {
      #{nested}#{props}
      }
    SWIFT
  end

  private

  def nested_blocks
    @structs.map do |s_name, props|
      Codegen.struct_block(
        name: s_name,
        properties: props,
        access: '',
        prefix: @prefix,
        defaults: @with_defaults,
        constructor: false,
        indent: 1
      )
    end.join("\n\n") + "\n"
  end

  def property_line(key, value)
    pname = Codegen.property_name(key)
    ptype = Codegen.swift_type(value, key, prefix: @prefix)
    lit   = Codegen.literal(value, key, prefix: @prefix)
    Codegen.indent("let #{pname}: #{ptype} = #{lit}")
  end
end

# Klasa odpowiedzialna za analizę typów i struktur w plist
class PlistAnalyzer
  def initialize(data)
    @data = data
    @struct_registry = {}
  end

  # Analizuje dane i zwraca strukturę metadanych
  def analyze
    collect_struct_definitions(@data)
    @struct_registry
  end

  private

  def collect_struct_definitions(data, parent_key = nil)
    data.each do |key, value|
      process_value(value, key)
    end
  end

  def process_value(value, key)
    case value
    when Hash
      register_struct_from_hash(value, key)
    when Array
      process_array(value, key)
    when OptionalValue
      process_value(value.value, key) if value.value
    end
  end

  def process_array(array, key)
    return if array.empty?
    
    dict_elements = array.select { |el| el.is_a?(Hash) }
    return if dict_elements.empty?
    
    register_struct_from_array(dict_elements, key)
  end

  def register_struct_from_hash(hash, key)
  struct_name = Codegen.struct_name(key)
    return if @struct_registry.key?(struct_name)
    
    @struct_registry[struct_name] = hash
    collect_struct_definitions(hash)
  end

  def register_struct_from_array(hash_array, key)
  struct_name = Codegen.array_struct_name(key)
    return if @struct_registry.key?(struct_name)
    
    merged_properties = merge_hash_properties(hash_array)
    @struct_registry[struct_name] = merged_properties
    collect_struct_definitions(merged_properties)
  end

  def merge_hash_properties(hash_array)
    return {} if hash_array.empty?
    
    all_keys = hash_array.flat_map(&:keys).uniq
    merged = {}
    
    all_keys.each do |key|
      sample_value = hash_array.find { |hash| hash.key?(key) }&.[](key)
      appears_in_all = hash_array.all? { |hash| hash.key?(key) }
      
      merged[key] = appears_in_all ? sample_value : OptionalValue.new(sample_value)
    end
    
    merged
  end
end

# Główna klasa generatora
class PlistToSwift
  def initialize(file, prefix:, skip_nested: true, output_dir: nil)
    @file = file
    @prefix = prefix
    @skip_nested = skip_nested
    @output_dir = output_dir
  end

  def generate
    data = Plist.parse_xml(@file)
    registry = PlistAnalyzer.new(data).analyze
    name = Codegen.main_struct_name(@file)
    generator = SwiftFileGenerator.new(structs: registry, prefix: @prefix, skip_nested: @skip_nested)
    code = generator.render_top_struct(name, data)
    path = build_output_path("#{name}.swift")
    Codegen.write_file(path, code)
  end

  private

  def build_output_path(filename)
    return filename if @output_dir.nil? || @output_dir.strip.empty?
    File.join(@output_dir, filename)
  end
end

# CLI Interface
class CLI
  VERSION = '2.1.0'.freeze

  def self.run
    options = parse_arguments
    return if options[:exit]
    
    input_file = ARGV[0]
    generator = PlistToSwift.new(
      input_file,
      prefix: options[:type_prefix],
      skip_nested: options[:skip_nested_structs],
      output_dir: options[:output_dir]
    )
    generator.generate
  end

  private

  def self.parse_arguments
  options = {}
    
  OptionParser.new do |opts|
      opts.banner = "Użycie: ruby plist_to_swift.rb [opcje] [ścieżka_do_pliku.plist]"
      
      opts.on("-h", "--help", "Pokaż tę pomoc") do
        options[:exit] = true
      end
      
      opts.on("-v", "--version", "Pokaż wersję") do
        options[:exit] = true
      end
      opts.on("--type-prefix NAME", "Dodaj prefiks do nazw struktur (np. Configuration)") do |name|
        options[:type_prefix] = name
      end
      opts.on("--skip-nested-structs", "Nie generuj zagnieżdżonych struktur w pliku docelowym") do
        options[:skip_nested_structs] = true
      end
      opts.on("-oDIR", "--output-dir DIR", "Katalog docelowy dla wygenerowanego pliku .swift") do |dir|
        options[:output_dir] = dir
      end
      # No protocol-related options; simplified generator
    end.parse!
    
    options
  end
end

# Uruchomienie programu
if __FILE__ == $0
  CLI.run
end

4.
#!/usr/bin/env ruby
# -*- coding: utf-8 -*-

require_relative 'codegen'

class ProtocolGenerator

  def generate_namespace_protocol(main_name, merged_data, struct_registry, output_dir: nil)
    namespace = "#{main_name}Namespace"
    protocol_name = "#{main_name}Protocol"

    props = build_protocol_properties(merged_data, namespace)
    protocol_code = render_protocol(protocol_name, props)
    namespace_code = render_namespace(namespace, struct_registry)

    base = (output_dir && !output_dir.to_s.strip.empty?) ? output_dir : nil
    Codegen.write_file(path_for(base, "#{namespace}.swift"), namespace_code)
    Codegen.write_file(path_for(base, "#{protocol_name}.swift"), protocol_code)
  end

  private

  def build_protocol_properties(data, namespace)
    data.map do |k, v|
      { name: Codegen.property_name(k), type: Codegen.swift_type(v, k, prefix: namespace) }
    end
  end

  def render_protocol(name, props)
  interface = props.map { |p| Codegen.indent("public var #{p[:name]}: #{p[:type]} { get }", 1) }.join("\n")
  defaults  = props.map { |p| Codegen.indent("var #{p[:name]}: #{p[:type]} { #{Codegen.default_for_type(p[:type])} }", 1) }.join("\n")
    <<~SWIFT
      import Foundation

      public protocol #{name} {
      #{interface}
      }

      public extension #{name} {
      #{defaults}
      }
    SWIFT
  end

  def render_namespace(namespace, structs)
    # Zbuduj graf zależności parent -> children (po typach własnych struktur)
    children_map = Hash.new { |h, k| h[k] = [] }
    referenced = Hash.new(false)

    # structs.each do |struct_name, props|
    #   props.each do |k, v|
    #     t = Codegen.swift_type(v, k)
    #     children_map[struct_name] << t unless children_map[struct_name].include?(t)
    #       referenced[t] = true
    #   end
    # end

    roots = structs.keys.reject { |name| referenced[name] }

    rendered = roots.map do |root|
      Codegen.struct_block_with_children(
        root,
        structs,
        children_map,
        access: 'public ',
        prefix: nil,
        defaults: true,
        constructor: true,
        indent: 1
      )
    end.join("\n\n")

    <<~SWIFT
      import Foundation

      public enum #{namespace} {
      #{rendered}
      }
    SWIFT
  end

  # render_struct_with_children nie jest już potrzebne – logika jest w Codegen.struct_block_with_children

  def path_for(dir, file)
    return file unless dir
    File.join(dir, file)
  end

end
